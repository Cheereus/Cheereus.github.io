---
layout:     post
title:      k近邻法
subtitle:   《统计学习方法》笔记 第3章
date:       2020-01-17
author:     Cheereus
header-img: img/post-bg-debug.png
catalog: true
tags:
    - Machine Learning
    - 统计学习方法
---

## 第3章 $k$ 近邻法

$k$ 近邻法($k$-nearest neighbor, $k$-NN)是一种基本分类与回归方法。

$k$ 近邻法的输入为实例的特征向量，对应于特征空间的点；输出为实例的类别，可以取多类。$k$ 近邻法假设给定一个训练数据集，其中的实例类别已定。分类时，对新的实例，根据其 $k$ 个最近邻的训练实例的类别，通过多数表决等方式进行预测。

$k$ 近邻法不具有显式的学习过程，实际上利用训练数据集对特征向量空间进行划分，并作为其分类的模型。$k$ 近邻法的三个基本要素：

* $k$ 值的选择
* 距离度量
* 分类决策规则

### 3.1 $k$ 近邻算法

输入：训练数据集

$$T=\{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\}$$

其中，$x_i \in \mathcal X = \mathcal{R}^n$ 为实例的特征向量，$y_i \in \mathcal{Y} = \\{c_1,c_2,\cdots,c_K\\}$ 为实例的类别，$i=1,2,\cdots,N$，实例特征向量 $x$；

输出：实例 $x$ 所属的类 $y$。

(1) 根据给定的距离度量，在训练集 $T$ 中找出与 $x$ 最邻近的 $k$ 个点，涵盖这 $k$ 个点的 $x$ 的邻域记作 $N_k(x)$；

(2) 在 $N_k(x)$ 中根据分类决策规则(如多数表决)决定 $x$ 的类别 $y$：

$$y=\arg\underset{c_j}{\max}\sum_{x_i\in N_k(x)}I(y_i=cj),i=1,2,\cdots,N;j=1,2,\cdots,K$$

其中 $I$ 为指示函数，即当 $y_i=c_j$ 时 $I$ 为1，否则为0.

$k$ 近邻法的特殊情况是 $k=1$ 的情形，称为最近邻算法。

### 3.2 $k$ 近邻模型

#### 3.2.1 模型

$k$ 近邻法中，当训练集、距离度量、$k$ 值及分类决策规则确定后，对于任何一个新的输入实例，它所属的类唯一地确定。这相当于根据上述要素将特征空间划分为一些子空间，确定子空间里的每个点所属的类。

#### 3.2.2 距离度量

设特征空间 $\mathcal X$ 是 $n$ 维实数向量空间 $R^n$，$x_i,x_j \in \mathcal{X},x_i=(x_i^{(1)},x_i^{(2)},\cdots,x_i^{(n)})^T,x_j=(x_j^{(1)},x_j^{(2)},\cdots,x_j^{(n)})^T,x_i,x_j$ 的 $L_p$ 距离或 Minkowski 距离定义为：

$$L_p(x_i,x_j)=\bigg( \sum_{l=1}^n{\vert x_i^{(l)}-x_j^{(l)} \vert ^p} \bigg)^{\frac{1}{p}}$$

这里 $p \geq 1$。当 $p=2$ 时，称为欧氏距离(Euclidean distance)，即：

$$L_2(x_i,x_j)=\bigg( \sum_{l=1}^n{\vert x_i^{(l)}-x_j^{(l)} \vert ^2} \bigg)^{\frac{1}{2}}$$

当 $p=1$ 时，称为曼哈顿距离(Manhattan distance)，即：

$$L_1(x_i,x_j)=\sum_{l=1}^n{\vert x_i^{(l)}-x_j^{(l)} \vert}$$

当 $p=\infty$ 时，它是各个坐标距离的最大值，即：

$$L_{\infty}(x_i,x_j)=\underset{l}{\max}{\vert x_i^{(l)}-x_j^{(l)} \vert}$$

#### 3.2.3 $k$ 值的选择

如果选择较小的 $k$ 值，近似误差(approximation error)会减小，但缺点是估计误差(estimation error)会增大，也就是说 $k$ 值的减小就意味着整体模型变得复杂，容易发生过拟合。

如果选择较大的 $k$ 值，优点是可以减少估计误差，缺点是近似误差会增大，模型变得简单。

在应用中， $k$值一般取一个比较小的数值。通常采用交叉验证法来选取最优的 $k$ 值。

#### 3.2.4 分类决策规则

多数表决规则(majority voting rule)：

如果分类的损失函数为 0-1 函数，分类函数为：

$$f:R^n \rightarrow \{c_1,c_2,\cdots,c_K\}$$

那么误分类的概率是：

$$P(Y \neq f(X))=1-P(Y=f(X))$$

对给定的实例 $x\in\mathcal{X}$，其最近邻的 $k$ 个训练实例点构成集合 $N_k(x)$。如果涵盖 $N_k(x)$ 的区域的类别是 $c_j$，那么误分类概率是：

$$\frac{1}{k}\sum_{x_i \in N_k(x)}{I(y_i \neq c_j)}=1-\frac{1}{k}\sum_{x_i \in N_k(x)}{I(y_i = c_j)}$$

要使误分类率最小即经验风险最小，就要使 $\sum_{x_i \in N_k(x)}{I(y_i = c_j)}$ 最大，所以多数表决规则等价于经验风险最小化。

### 3.3 $k$ 近邻法的实现：$kd$ 树

#### 3.3.1 构造平衡 $kd$ 树

输入：$k$ 维空间数据集 $T=\\{x_1,x_2,\cdots,x_N\\}$，其中 $x_i=(x_i^{(1)},x_i^{(2)},\cdots,x_i^{(k)})^T,i=1,2,\cdots,N$

输出：$kd$ 树

(1) 开始：构造根节点，根节点对应于包含 $T$ 的 $k$ 维空间的超矩形区域。

选择 $x^{(1)}$ 为坐标轴，以 $T$ 中所有实例的 $x^{(1)}$ 坐标的中位数为切分点，将根节点对应的超矩形区域切分为两个子区域。切分由通过切分点并与坐标轴 $x^{(1)}$ 垂直的超平面实现。

由根节点生成深度为 1 的左、右子节点：左子节点对应坐标 $x^{(1)}$ 小于切分点的子区域，右子节点对应于坐标 $x^{(1)}$ 大于切分点的子区域。

将落在切分超平面上的实例点保存在根节点。

(2) 重复：对深度为 $j$ 的节点，选择 $x^{(l)}$ 为切分的坐标轴，$l=j(mod\ {k})+1$，以该节点的区域中所有实例的 $x^{(l)}$ 坐标的中位数为切分点，将该节点对应的超矩形区域切分为两个子区域。切分由通过切分点并与坐标轴 $x^{(l)}$ 垂直的超平面实现。

由该节点生成深度为 $j+1$ 的左、右子节点：左子节点对应坐标 $x^{(l)}$ 小于切分点的子区域，右子节点对应坐标 $x^{(l)}$ 大于切分点的子区域。

将落在切分超平面上的实例点保存在该节点。

(3) 直到两个子区域没有实例存在时停止。从而形成 $kd$ 树的区域划分。

#### 3.3.2 $kd$ 树的最近邻搜索

输入：已构造的 $kd$ 树，目标点 $x$;

输出：$x$ 的最近邻。

(1) 在 $kd$ 树中找出包含目标点 $x$ 的叶节点：从根节点出发，递归地向下访问 $kd$ 树。若目标点 $x$ 当前维的坐标小于切分点的坐标，则移动到左子节点，否则移动到右子节点。直到子节点为叶节点为止。

(2) 以此叶节点为“当前最近点”。

(3) 递归地向上回退，在每个节点进行以下操作：

1. 如果该节点保存的实例点比当前最近点距离目标点更近，则以该实例点为“当前最近点”。
2. 当前最近点一定存在于该节点一个子节点对应的区域。检查该子节点的父节点的另一子节点对应的区域是否有更近的点。具体地，检查另一子节点对应的区域是否与以目标点为球心，以目标点与“当前最近点”间的距离为半径的超球体相交。如果相交，可能在另一个子节点对应的区域内存在距目标点更近的点，移动到另一个子节点。接着，递归地进行最近邻搜索。如果不相交，向上回退。
3. 当回退到根节点时，搜索结束。最后的“当前最近点”即为 $x$ 的最近邻点。

如果实例点是随机分布的， $kd$ 树搜索的平均计算复杂度是 $O(\log N)$，这里 $N$ 是训练实例数。

$kd$ 树更适用于训练实例数远大于空间维数的 $k$ 近邻搜索。当空间维数接近训练实例数时，它的效率会迅速下降，几乎接近线性扫描。

### 第3章完结
